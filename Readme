ğŸ“‚ Deployment-strategy-and-Gitops-with-ArgoCD/README.md

# ğŸš€ Deployment Strategies & GitOps with Argo CD

This project demonstrates how to deploy and manage a **containerized application** on Kubernetes using:
- **Rolling Updates** for zero-downtime deployments  
- **Horizontal Pod Autoscaler (HPA)** for auto-scaling under load  
- **Jobs & Load Generators** for traffic simulation  
- **Argo CD** for GitOps-driven automation  

---

## ğŸ“Œ Features
- Rolling update strategy with controlled surge/unavailable Pods  
- Readiness & liveness probes for self-healing  
- Resource requests/limits to enable autoscaling  
- HPA scaling between 2â€“6 replicas based on CPU utilization  
- Load simulation with Jobs and Deployments  
- Automated GitOps sync with Argo CD  
- Optional **Argo CD Image Updater** for auto-deploying new container versions  


## âš™ï¸ Setup Instructions

### 1. Clone the Repo
```bash
git clone https://github.com/Demystifier-git/Deployment-strategy-and-Gitops-with-ArgoCD.git
cd Deployment-strategy-and-Gitops-with-ArgoCD

2. Switch Branch to Main
git branch -m master main
git push -u origin main
git push origin --delete master

3. Deploy Application
kubectl apply -f kubernetes.yamlfiles/

4. Verify Deployment
kubectl get pods
kubectl get svc

5. Trigger Rolling Update
kubectl set image deployment/myapp-deployment myapp=demystifier/myapp:2.0
kubectl rollout status deployment/myapp-deployment

6. Horizontal Pod Autoscaler
kubectl get hpa
kubectl get pods -w

7. Deploy with Argo CD
kubectl apply -f argo-app-myapp.yaml -n argocd
kubectl get applications -n argocd
ğŸ“Š Scaling Test
Run a load generator Job for 10 minutes:


kubectl apply -f load-generator-job.yaml
kubectl get pods
kubectl logs <load-pod-name>
Pods will scale up under load and scale down automatically when traffic reduces.
Jobs will clean up automatically when finished. âœ…

ğŸ”„ GitOps Workflow with Argo CD
Commit & push manifest updates to GitHub

Argo CD detects changes â†’ syncs with cluster

Kubernetes handles rolling update automatically

ğŸ”® Future Enhancements
Add CI/CD pipeline with GitHub Actions

Automate image tag updates with Argo CD Image Updater

Integrate monitoring dashboards with Prometheus & Grafana

ğŸ“Œ Repository
ğŸ‘‰ Deployment-strategy-and-Gitops-with-ArgoCD

# ğŸš€ Canary Release with Kubernetes

This project shows how to safely roll out new versions of an application using **Kubernetes Canary Releases**.  
Instead of replacing everything at once, we gradually send a small portion of traffic to the new version while most users stay on the stable version.

---

## ğŸ“Œ What is a Canary Release?
A **canary release** is a deployment strategy where:
- You deploy a new version (canary) alongside the current stable version.
- Only a small percentage of traffic goes to the canary.
- If everything looks good, you increase traffic gradually until the canary becomes the new stable.
- If issues show up, you roll back quickly without affecting all users.

Think of it like sending a *canary bird into the coal mine first* â€” if itâ€™s safe, everyone else follows ğŸ¦.

---

## ğŸ› ï¸ Whatâ€™s Inside
- **Deployments** for `stable` and `canary` versions of the app.
- **Services** to route traffic.
- **Ingress / Istio VirtualService** (depending on setup) to split traffic between versions.
- Sample app to test how requests are served by different versions.

ğŸ‘¨â€ğŸ’» Author
Delight David
DevOps Engineer | Cloud & Kubernetes Enthusiast